var atkType = 2;
var goldCoins = 0;
var spanningRadius = 100;
var normalizedVector;
var numInBlast = 0;
var goldStormCD;
var cageDirectionVector;
var initialArmy = false;
var cooldownResetTime = this.now();

loop { // jshint ignore:line
  var corpses = this.findCorpses();
  var yeti = this.findByType("yeti");
  var cage = this.findByType("cage");
  var enemies = this.findEnemies();
  var enemySorcerer = this.findNearest(this.findByType('sorcerer'));
  var friends = this.findFriends();
  var enemySoldiers = [];
  var soldiersCount = 0;
  var i = 0;
  var j = 0;

  for (i=0; i < enemies.length; ++i) {
    if (enemies[i].type === 'soldier') {
      enemySoldiers.push(enemies[i]);
    }
  }


  // She also commands your allies in battle.
  for (i=0; i < friends.length; ++i) {
    var friend = friends[i];
    var validTargets = [];
    if (friend.type === 'soldier') {
      soldiersCount++;
    }
    if (friend.type !== 'cage') {
      for (j = 0; j < enemies.length; j++) {
        if ( enemies[j].type !== 'cage' ) {
          validTargets.push(enemies[j]);
        }
      }
      this.command(friend, "attack", friend.findNearest(validTargets));
    }
  }

  // Your hero can collect coins and summon troops.
  if (this.gold > this.costOf("soldier") && soldiersCount < 4 && !initialArmy) {
    soldiersCount++;
    this.summon("soldier");
    if (soldiersCount >= 4) {
      initialArmy = true;
    }
    continue; // jshint ignore:line
  } else if (this.gold > this.costOf("soldier") && (enemySoldiers > soldiersCount)) {
    soldiersCount++;
    this.summon("soldier");
    continue; // jshint ignore:line
  } else if(this.gold > this.costOf("archer") && atkType >= 3) {
    this.summon("archer");
    continue; // jshint ignore:line
  } else if(this.gold > this.costOf("griffin-rider")) {
    atkType++;
    this.summon("griffin-rider");
    continue; // jshint ignore:line
  }

  // Use your hero's abilities to turn the tide.
  if(!this.canCast("fear") && this.now() > cooldownResetTime) {
    this.resetCooldown('fear');
    cooldownResetTime = this.now() + 20;
  }

  if(enemySorcerer && this.canCast("fear", enemySorcerer)) {
    this.cast("fear", enemySorcerer);
    continue; // jshint ignore:line
  }

  if(enemySorcerer && this.canCast("manaBlast", enemySorcerer)) {
    this.cast("manaBlast", this.findNearest(enemies));
    continue; // jshint ignore:line
  }

  if(corpses.length > 0 && this.canCast('raise-dead') && this.distanceTo(this.findNearest(corpses)) < 15) {
    this.cast('raise-dead');
    continue; // jshint ignore:line
  }

  if(true) {
    goldCoins = 0;
    var items = this.findItems();
    var desiredDirectionX = 0;
    var desiredDirectionY = 0;
    for(var c=0; c<items.length; ++c) {
      if(this.distanceTo(items[c]) > spanningRadius) {
        continue; // jshint ignore:line
      }
      var multiplier = 1/(this.distanceTo(items[c])/items[c].value);
      var vDiff = Vector.subtract(items[c].pos, this.pos);
      var direction = Vector.multiply(Vector.normalize(new Vector(vDiff.x, vDiff.y)), 1/(Math.pow((this.distanceTo(items[c])), 2.24)));

      desiredDirectionX += direction.x * Math.pow(items[c].bountyGold, 2.14) * multiplier;
      desiredDirectionY += direction.y * Math.pow(items[c].bountyGold, 2.14) * multiplier;
      if(items[c].value >= 3) {
        goldCoins++;
      }
    }
    if(goldCoins > 20) {
      spanningRadius--;
    } else {
      spanningRadius++;
    }
    normalizedVector = Vector.normalize(new Vector(desiredDirectionX, desiredDirectionY));
    if(numInBlast < 3 && this.now() > goldStormCD) {
      this.cast("goldstorm");
      goldStormCD = this.now() + 15;
    }
    if(cage.length > 0 && this.distanceTo(cage[0]) < 5) {
      cageDirectionVector = Vector.normalize(Vector.subtract(this.pos, cage[0].pos));
      normalizedVector = Vector.normalize(Vector.add(cageDirectionVector, normalizedVector));
    }
    this.move(Vector.add(Vector.multiply(normalizedVector, 10), new Vector(this.pos.x, this.pos.y)));
    continue; // jshint ignore:line
  }

}

